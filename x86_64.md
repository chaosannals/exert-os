# x86_64

## IA-32e 分页

虚拟地址（64位）

12bit 正好表示 4KB
21bit 正好表示 2MB
30bit 正好表示 1GB

- 4KB: 16（空）+ 9（4Lv） + 9（3Lv） + 9（2Lv）+ 9（1Lv） + 12（页内位移）
- 2MB: 16（空）+ 9（4Lv） + 9（3Lv） + 9（2Lv）+ 21（页内位移）
- 1GB: 16（空）+ 9（4Lv） + 9（3Lv） + 30（页内位移）

Cr3： 高52位基址，12位（标识只有几位可用）

表帧宽 64bit 正好 8 字节，不同 Lv 是帧索引，8 字节是 2^3 使得 9 + 3 = 12，所以每个表大小实际上是 2^12=4KB。

- Lv4 物理地址 = Cr3基址 + 8 * 9（4Lv)
- Lv3 物理地址 = Lv4获取 + 8 * 9（3Lv) (注：如果是大页 1G，物理地址 = 拿到的基址 + 30（页内位移) 就是物理地址)
- Lv2 物理地址 = Lv3获取 + 8 * 9（2Lv)（注：如果是中页 2M，物理地址 = 拿到的基址 + 21（页内位移）就是物理地址)
- Lv1 物理地址 = Lv2获取 + 8 * 9 (1Lv) (注：物理地址 = 拿到的基址 + 12 （页内位移）就是物理地址)
- 指针的物理地址 = 以上 L1 L2 L3 不同级别的表帧中拿到（基址）加（页内位移）得到，详见上注。

### 页表帧结构

- 0 页是否在内存中
- 1 是否可写
- 2 是否用户态可访问（为 0 只有 ring0 可以访问）
- 3 是否写入直接进入内存
- 4 是否禁止缓存
- 5 是否被使用（CPU自动设置）
- 6 是否被写入（CPU自动设置）dirty
- 7 huge page Lv1 和 Lv4 为0，Lv3 为 1G 页，Lv2 为 2M 页
- 8 global 地址空间切换时，页面不会被换出cache ( CR4 中的PGE 位必须被设置)
- 9-11  (随意)
- 12-51 （物理基址 40位）
- 52-62 （随意）
- 63 禁止将这个页面上的数据当作代码执行 (EFER寄存器中的NXE位必须被设置)
